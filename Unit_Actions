let moveUnit : (GameState, (u8, u8), (u8, u8), [[(u8, u8, u8, Bool, Bool, Bool)]]) -> (GameState, [[(u8, u8, u8, Bool, Bool, Bool)]]) =
  \ (gameState, (x1, y1), (x2, y2), playerStatiArray) ->
    let (x1', y1', z1') = coordinateMap (x1, y1)
        (x2', y2', z2') = coordinateMap (x2, y2)
        unitAttrs = gameState[toIndex x1'][toIndex y1'][playerId]
        (health, attack, speed, range, flying, areaEffect, cardID, instance) =
          (unitAttrs[0], unitAttrs[1], unitAttrs[2], unitAttrs[3], unitAttrs[4], unitAttrs[5], unitAttrs[6], unitAttrs[7])
        width = 30  -- Updated width for cube coordinates
        height = 22  -- Updated height for cube coordinates
        depth = 22  -- Updated depth for cube coordinates
        -- Retrieve unit's status from the playerStatiArray
        currentPlayerStati = playerStatiArray[playerId]
        unitStatus = lookupDefault (cardID, instance, 0, False, False, False) currentPlayerStati
        -- Check if the unit has actions left
        hasActionsLeft = unitStatus[2] > 0
        -- Check if the unit has a half-integer speed and hasn't moved
        shouldMove =
          case speed % 1.0 of
            0.5 -> not (unitStatus[3])
            _ -> true

    -- Check if the move is valid and the unit has actions left
    if isValidMove x1' y1' z1' x2' y2' z2' gameState == 0 || not hasActionsLeft || not shouldMove
    then
      (gameState, playerStatiArray)  -- Target position is unreachable, or the unit has no actions left, or can't move due to its half-integer speed and having moved
    else
      let updatedGameState = map (\x ->
                                   map (\y ->
                                          map (\z ->
                                                 if (x, y, z) == (x1', y1', z1')
                                                 then (-1, -1, -1.0, -1.0, False, False, -1, -1)
                                                 else if (x, y, z) == (x2', y2', z2')
                                                      then (health, attack, speed, range, flying, areaEffect, cardID, instance)
                                                      else gameState[x][y][z])
                                     (iota depth))
                               (iota height))
                            (iota width)
          updatedPlayerStatiArray = map (\unit ->
                                           if unit == unitStatus
                                           then (cardID, instance, unit[2] - 1, True, unit[4], unit[5])
                                           else unit)
                                         currentPlayerStati
      in
      (updatedGameState, updateAt playerStatiArray playerId updatedPlayerStatiArray)
